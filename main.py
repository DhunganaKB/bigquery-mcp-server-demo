# main.py
"""
Main entry point for the FastAPI application.
This module defines the API endpoints for the BigQuery MCP server, handling user queries
and routing them to the AI agent for processing.
"""
import os
import re
import asyncio

from dotenv import load_dotenv
from fastapi import FastAPI
from pydantic import BaseModel

from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types
from google.adk.errors.already_exists_error import AlreadyExistsError

from agent import root_agent
from constants import PROJECT_ID, LOCATION, APP_NAME, TABLES

# Load environment variables from .env file
load_dotenv()

# Initialize FastAPI app
app = FastAPI()

class QueryRequest(BaseModel):
    """
    Request model for the /query endpoint.
    """
    question: str
    user_id: str = "user1234"
    session_id: str = "default-session"


class QueryResponse(BaseModel):
    """
    Response model for the /query endpoint.
    """
    answer: str

# Initialize session service for managing user sessions
session_service = InMemorySessionService()

async def _ensure_session(app_name: str, user_id: str, session_id: str):
    """
    Ensures that a session exists for the given user and app.
    If the session already exists, it ignores the error.
    """
    try:
        await session_service.create_session(
        app_name=app_name,
        user_id=user_id,
        session_id=session_id,
    )
    except AlreadyExistsError:
        pass


@app.post("/query", response_model=QueryResponse)
async def query_bigquery(body: QueryRequest):
    """
    Endpoint to process user questions about BigQuery data.
    
    Args:
        body (QueryRequest): The request body containing the question, user_id, and session_id.
        
    Returns:
        QueryResponse: The answer generated by the agent.
    """
    # Ensure a session exists for this interaction
    await _ensure_session(APP_NAME, body.user_id, body.session_id)

    # Build table list from constants.TABLES to provide context to the agent
    table_lines = []
    for idx, t in enumerate(TABLES, start=1):
        fq = f"{PROJECT_ID}.{t['dataset']}.{t['table']}"
        table_lines.append(f"  {idx}. {fq}")
    tables_block = "\n".join(table_lines)

    # Construct the user query with context about the environment and available tables
    user_query = (
        f"User question: {body.question}\n\n"
        f"Project ID: {PROJECT_ID}\n"
        f"Location: {LOCATION}\n"
        f"Available BigQuery tables (fixed for this app):\n"
        f"{tables_block}\n\n"
        "You may also use get_table_info, get_dataset_info, or execute_sql\n"
        "for schema inspection or precise SQL queries.\n"
        "argument from the above list of tables."
    )

    # Create the content object for the agent
    content = types.Content(
        role="user",
        parts=[types.Part(text=user_query)],
    )

    try:
        # Initialize the runner with the agent and session service
        runner = Runner(
            agent=root_agent,
            app_name=APP_NAME,
            session_service=session_service,
        )

        # Run the agent asynchronously
        events = runner.run_async(
            user_id=body.user_id,
            session_id=body.session_id,
            new_message=content,
        )

        final_text = ""
        # Process events from the agent
        async for event in events:
            if event.is_final_response():
                if event.content and event.content.parts:
                    part = event.content.parts[0]
                    if getattr(part, "text", None):
                        final_text = part.text
        
        # Return the final answer
        return QueryResponse(
            answer=final_text or "[no response from agent]"
        )

    except Exception as e:
        print(f"‚ùå An error occurred: {e}")
        # Return a generic error response instead of crashing
        return QueryResponse(answer=f"Error processing request: {str(e)}")
